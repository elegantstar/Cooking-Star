# CookingStar

요리 사진을 공유하고 이야기할 수 있는 소셜 미디어 서비스입니다.  
현재까지는 이미지 기반의 소셜 미디어 서비스이지만, 추후 레시피까지 공유할 수 있는 커뮤니티를 염두에 두고 개발하였습니다.

## 기술 스택

- `Spring-boot` Version 2.6.2
  - `Java` Version SE 11
  - `Gradle`
  - `Spring Framework` Version 5.3.14
  - `Thymeleaf` Version 3.0.4
  - `JUnit` Version 5.8.2
  - `Mybatis` Version 3.5.9
  - `Mysql` Version 8.0.27
  - `Lombok` Version 1.18.22
  - `Spring Data JPA` Version 2.6.0

<br>

- `Javascript`
- `Bootstrap` Version 5.1.3
- `jQuery` Version 3.6.0

<br>

- `AWS S3`
- `AWS IAM`
- `AWS CloudFront`

<br>

- `Github`

## 데이터베이스 구조

<img src=https://raw.githubusercontent.com/elegantstar/SocialMedia-like-Instagram/develop/images/erd.png>

## 기능 구현

### 회원 정보 저장

회원 정보 중 `패스워드`를 데이터베이스에 원문 그대로 직접 저장하는 것은 굉장히 위험하기 때문에 `해싱`하여 저장하였습니다.

- `SHA-256` 해시 알고리즘을 사용하였습니다.
- `SHA-256`는 동일한 패스워드에 대해 동일한 해시값을 반환한다는 문제가 있었습니다. 따라서 `salt`라는 난수를 생성하여 패스워드에 더한 값을 `SHA-256`으로 해싱하여 동일한 패스워드에 대해 다른 해시값을 가질 수 있도록 개발했습니다.

<img src="https://raw.githubusercontent.com/elegantstar/SocialMedia-like-Instagram/develop/images/member_password.png">

<br>

### 이미지 업로드(포스팅 - 사진 파일 업로드)

이미지 저장소는 1차 개발 단계에서 `로컬 디스크`를 사용하는 방식으로 구현하였으나, 이후 `AWS S3`를 사용하는 것으로 리팩토링을 진행하였습니다. 이미지 업로드는 `비동기`로 이루어지며, 최종 프로토콜은 아래와 같습니다.

1. 클라이언트가 서버에 이미지 파일을 전송합니다.
2. 서버는 클라이언트로부터 받은 이미지 파일명을 별도의 알고리즘을 통해 `고유한 이름`으로 변경하여 S3에 저장하고, 변경된 고유한 파일명을 `URI`로 한 이미지 파일의 `URL`을 클라이언트에 전달합니다.

#### 이미지 파일 저장소를 로컬 디스크에서 AWS S3로 변경한 이유

`안정성`, `확장성`, `서비스 배포`를 고려하여 변경하였습니다. 서버를 띄우는 로컬 디스크에 파일을 저장하는 것은 응답속도 면에서 매우 빠르지만, **파일의 안정적인 관리 측면에서는 많은 리스크가 존재하기에 원격 저장소가 필요하다고 판단**했습니다. 또한, 추후 서비스 배포를 염두에 두고 개발을 진행하였기 때문에 **서비스의 안정적인 운영** 측면에서도 필요한 선택이었습니다.
`S3`는 매우 높은 안정성을 보유하고 있으며, 추가적인 저장 공간이 필요한 경우에도 어렵지 않게 확장할 수 있다는 장점이 있습니다. 또한, `AWS IAM`의 연동으로 스토리지 관리자의 권한을 적절히 제한할 수 있다는 점에서도 파일을 안정적으로 관리하기에 적합한 선택이었다고 생각합니다.

### 이미지 파일 응답 속도 저하 이슈

파일의 저장소를 로컬에서 S3로 변경하면서 **이미지 파일 요청에 대한 응답 속도가 현저히 저하되는 이슈가 발생**하였습니다. 이는 크게 **두 가지 측면에서 문제가 있음을 파악**하였고 다음과 같은 방식으로 해결했습니다.

#### 1. 서버를 통해 이미지 파일을 전달하는 방식의 문제점

이미지 파일을 로컬 디스크 저장소에 저장할 때에는 서버에서 `urlResource`를 이용해 클라이언트에 직접 이미지 파일을 전달했었습니다. 그러나 이러한 방식이 `성능 저하 이슈`와 `네트워크 대역폭 이슈`를 야기함을 인지하여 **클라이언트에서 S3 저장소에 직접 파일을 요청할 수 있도록 변경**하였습니다.

##### 1) 매우 느린 응답 속도

**크기가 큰 이미지 파일을 서버에서 받아 클라이언트에 재전달 하는 과정에서 통신 부하가 크게 발생하였고, 이는 성능 저하의 원인이 되었습니다.** 클라이언트에서 직접 파일을 요청하도록 변경하는 것을 통해 응답 속도를 크게 개선할 수 있었습니다. 기존 방식의 경우 이미지 파일 하나에 대한 응답 속도는 **200ms** 내외로 사용자가 크게 불편을 느낄만한 수준이었으나, 변경 이후에는 **평균 45ms**으로 기존 대비 75% 이상 향상되었습니다.

| 이미지 파일 전송 방식                    | 응답 속도(이미지 1개) | 응답 속도(이미지 10개) |
| ---------------------------------------- | --------------------- | ---------------------- |
| 서버를 거쳐서 클라이언트에 전달하는 방식 | 평균 200ms            | 평균 400ms 이상        |
| 클라이언트에서 S3에 직접 요청하는 방식   | 평균 45ms             | 평균 58ms              |

##### 2) 대역폭 이슈

서버에서 이미지 파일을 직접 받아 재전달 하는 방식은 이용자가 많아지면 더욱 큰 문제를 야기합니다.

#### 2. 원격 서버 사용으로 인한 응답 속도 저하

클라이언트에서 S3 저장소의 이미지를 직접 요청하는 것만으로도 충분히 응답 속도를 개선할 수 있었지만, 경우에 따라서는 사용자 입장에서 여전히 불편함을 느낄 수 있는 부분이라고 생각했습니다. 이러한 문제는 `CDN` 연동과 `캐싱`으로 개선할 수 있었습니다.

##### AWS Cloudfront 연동 및 캐싱

성능 이슈 해결을 위해 고민하던 중에 AWS에서 제공하는 `CDN 서비스(Cloudfront)`가 있다는 것을 알게 되었습니다. S3의 버킷을 `Region`을 '아시아 태평양(서울) ap-northeast-2'로 만들긴 했으나, 그 외 지역에서도 **준수한 성능을 내기 위해서는 Cloudfront 사용이 필수적이라고 판단**하여 적용하였습니다.  
Cloudfront는 S3에 대한 원본 파일을 `Caching`하는 것이 가능했고, `브라우저 캐시`까지 설정할 수 있었습니다. 현재 프로젝트 정책 상 이미지에 대한 수정은 허용하지 않기에 Cache의 기간을 충분히 크게 설정하여 응답 속도를 개선하였습니다.

| 응답 서버  | 응답 속도(이미지 1개) | 응답 속도(이미지 10개) |
| ---------- | --------------------- | ---------------------- |
| S3         | 평균 45ms             | 평균 58ms              |
| Cloudfront | 평균 36ms             | 평균 44ms              |

<br>

### Mybatis에서 JPA로 전환

1차 개발 단계에서는 `Mybatis`를 사용하여 개발하였으나 이후 `JPA`로 전환을 결정했습니다. JPA로 전환하면서 **Entity, Repository, Service, Controller Layer 전반에 걸쳐 리팩토링을 진행**하였습니다.

#### JPA로 전환하게 된 이유

Mybatis를 사용하여 개발하는 것 자체에는 아무런 문제가 없었으나 사용하면서 몇 가지 불편함을 느꼈습니다.

- DB 테이블 생성 시마다 `반복적인 SQL 쿼리 작성`이 불가피한 점.
- DB 테이블에 변경 사항이 생길 시, 관련된 SQL 쿼리를 전부 수정해야 하는 점.
- 객체 지향 프로그래밍을 하면서 Mybatis로 조회해 온 객체는 `객체 그래프 탐색이 불가능`한 점.

JPA를 공부하면서, 개발 과정에서 막연하게 느꼈던 불편함이 어디에서 기인한 것인지 확실히 알게 되었습니다. 그리고 **SQL Mapper와 ORM 기술 두 가지를 모두 경험해 보는 것이 개발자로서의 시야를 넓힐 수 있는 방법**이 될 것이라는 확신이 들어 전환을 결정하였습니다. JPA를 적용하기 위해 기존 코드를 모두 리팩토링하였고, 훗날 프로젝트 규모가 커지고 복잡한 쿼리들이 많아지면 Mybatis와 함께 사용하는 것이 유리할 수 있다고 판단하여 Mybatis 코드는 삭제하지 않고 따로 모아두었습니다.

<br>

### 무한 스크롤 페이징

마이 페이지와 유저 페이지에서 해당 계정으로 게시한 전체 게시물을 조회할 수 있습니다. 이미지 기반의 소셜 미디어이기 때문에 게시물 노출 방식을 무한 스크롤 페이징 방식으로 구현하였습니다. 조회 결과, 다음 페이지의 존재 여부만 알면 다음 조회 요청 여부를 결정할 수 있기 때문에 `Slice`를 사용하였습니다. 클라이언트의 비동기 요청은 `async/await`, `fetch`를 이용하여 구현하였습니다.

1. 클라이언트에서 게시물 조회 요청이 오면 서버는 Paging 조건에 맞춰 조회 결과를 Slice에 담아 응답한다.
2. 클라이언트에서는 slice의 last 값이 true인지 false인지 확인하고 그 값을 저장해둔다. (페이지 내에 infiniteScrollSwitch 변수를 두고 slice.last 값이 false이면 "on", true이면 "off"로 변경)
3. slice 값이 last가 아닌 경우, 스크롤이 최하단에 도달하면 다음 페이지 조회를 요청한다.

무한 스크롤 페이징은 팔로워 목록과 팔로잉 목록을 확인할 때에도 사용하였습니다.

### 게시물 상태

게시물은 `게시("POSTING")`, `임시저장("TEMPORARY_STORAGE")`, `보관("PRIVATE")` 이렇게 세 가지 Status로 구분됩니다.

**게시 상태**  
신규 포스팅 페이지에서 게시 버튼을 누르면 status 속성은 "POSTING"으로 저장되며, 생성된 Post의 상세 페이지로 이동합니다.

**임시 저장 상태**  
임시저장 버튼을 누르면 해당 status 속성이 "TEMPORARY_STORAGE"로 저장되며, 이 경우 마이페이지로 이동됩니다. 임시 저장 게시물은 상단 네비게이션 바의 '임시 저장 목록' 버튼을 클릭하여 비동기 조회가 가능합니다.

**보관 상태**  
게시물 수정 페이지에서 보관 버튼을 누르면 status 속성이 "PRIVATE"으로 변경되며 게시물 노출 영역에 노출되지 않습니다. 보관 게시물은 마이페이지의 '보관함' 탭에서 따로 확인할 수 있습니다.

### 댓글, 좋아요

`async/await`, `fetch`를 이용하여 `댓글`과 `좋아요` 기능을 구현하였습니다. 게시물 상세 페이지에서 댓글 작성을 할 수 있으며, 게시물에 대한 좋아요와 댓글에 대한 좋아요 모두 구현하였습니다.

**댓글**

- 게시물의 글 영역 아래에 바로 댓글이 작성일자 순으로 노출됩니다.
- 지나친 댓글 노출을 막기 위해 '댓글 더보기' 버튼을 클릭 시 다음 페이지를 불러옵니다.
- 게시글 상세 페이지 하단의 댓글 입력란을 통해 댓글을 등록할 수 있으며, 댓글이 입력되면 게시 버튼이 활성화 됩니다.
- 댓글 게시 버튼을 누르면 해당 댓글은 댓글 영역 최상단에 노출됩니다. 최상단에 노출된 댓글은 '댓글 더보기' 버튼으로 조회되지 않습니다. (중복 노출 방지)
- 댓글 작성자는 자신의 댓글의 `...` 버튼을 통해 댓글 삭제가 가능합니다.
- 댓글 작성자의 아이디를 클릭하면 해당 유저의 페이지로 이동합니다.

※댓글의 Entity는 대댓글 기능 구현을 고려하여 ParentComment와 연관관계 매핑이 되어 있지만, 대댓글 구현은 아직 진행하지 않은 상태입니다.

**좋아요**

- 유저가 게시물 또는 댓글의 `좋아요` 버튼을 클릭하면 '좋아요' 개수가 갱신되고, 취소 시에도 갱신됩니다.
- 또한 '좋아요' 버튼 클릭 시 '좋아요' 클릭한 유저 목록에서 조회가 가능합니다. 목록 내 유저 아이디를 클릭하면 해당 유저의 페이지로 이동합니다.
- 게시물에 대한 '좋아요' 현황은 댓글 입력 창 바로 위에 위치하고 있으며, 댓글에 대한 좋아요는 각 댓글 하단 영역에 위치합니다.

### 유저 팔로우

`async/await`, `fetch`를 이용하여 팔로우 기능을 구현했습니다. 다른 유저의 페이지에 방문하여 `팔로우/언팔로우` 할 수 있습니다. 유저 페이지 상단의 `팔로워`, `팔로우` 영역을 클릭하면 팔로워, 팔로잉 목록을 확인할 수 있으며 목록에 노출된 유저들에 대해서도 팔로우/언팔로우가 가능합니다.

**다른 유저 페이지에서의 팔로우 기능**

- 다른 유저의 페이지 방문 후, 유저ID 우측 `팔로우` 버튼을 클릭하면 팔로우 가능합니다.
- 팔로우 버튼을 클릭하면 `팔로우` 버튼은 사람 아이콘으로 바뀌고, 해당 유저의 팔로워 수가 갱신됩니다.
- 해당 유저는 나를 팔로우 하지만, 나는 팔로우 하지 않는 상태일 때에는 `맞팔로우` 버튼으로 노출됩니다.
- 다른 유저의 페이지에서 `팔로워`, `팔로우` 영역을 클릭하면 팔로워, 팔로잉 목록을 확인할 수 있으며 목록에 노출된 유저들에 대해서도 팔로우/언팔로우가 가능합니다.
- 목록 내 유저 아이디를 클릭하면 해당 유저의 페이지로 이동합니다.

**마이 페이지의 팔로워 목록**

- `팔로워` 영역을 클릭하면 나를 팔로우 하는 유저 목록을 확인할 수 있습니다.
- 팔로워 목록 우측의 `삭제` 버튼을 클릭하면 해당 유저의 팔로우를 강제로 끊을 수 있으며, 삭제 시 팔로워 수가 갱신됩니다.
- 팔로워 목록의 유저들 중에서 내가 팔로우 하지 않는 유저의 아이디 옆에는 `팔로우` 버튼이 나타납니다. 이 버튼을 클릭하여 팔로우할 수 있습니다. 팔로우 버튼 클릭 시, 팔로워 수가 갱신됩니다.
- 목록 내 유저 아이디를 클릭하면 해당 유저의 페이지로 이동합니다.

**마이 페이지의 팔로잉 목록**

- `팔로우` 영역을 클릭하면 내가 팔로우 하는 유저 목록을 확인할 수 있습니다.
- 팔로잉 목록 우측의 `팔로잉` 버튼을 클릭하면 `팔로우` 버튼으로 변경되고 `언팔로우`됩니다. `팔로우` 버튼을 다시 클릭하면 `팔로잉` 버튼으로 변경되고 `팔로우`가 됩니다. 단, `팔로우` 버튼으로 바뀐 뒤 모달창을 벗어나면 해당 유저는 언팔로우 상태이기 때문에 팔로잉 목록에 노출되지 않습니다. 클릭 결과에 따라서 팔로우 수가 실시간으로 갱신됩니다.
- 목록 내 유저 아이디를 클릭하면 해당 유저의 페이지로 이동합니다.

### 유저 검색

`async/await`, `fetch`를 이용하여 구현하였습니다. 상단 네비게이션바의 검색창을 통해 유저를 검색할 수 있으며, 최근 검색 기록을 확인할 수 있습니다.

**유저 검색**

키워드를 입력하면, 유저ID 또는 닉네임에 해당 키워드가 포함된 유저들이 조회됩니다. 키워드가 변경되면 변경된 키워드에 맞춰 실시간으로 조회 결과를 불러옵니다. 조회 결과에 나타난 유저를 클릭하면 해당 유저의 페이지로 이동하며, 해당 유저는 최근 검색 기록에 저장됩니다.

**최근 검색 기록**

- 검색창을 클릭하고 아무런 키워드도 입력하지 않으면 `최근 검색 기록`을 보여줍니다. 가장 최근에 검색했던 순으로 정렬됩니다.
- 최근 검색 목록의 유저를 클릭하면 해당 유저의 페이지로 방문하며, 최근 검색 날짜가 갱신됩니다.
- 유저 목록의 X 버튼을 클릭하면 해당 유저에 대한 검색 기록이 삭제되며, `모두 지우기` 버튼을 클릭하면 최근 검색 기록이 모두 삭제됩니다.

#### 쿼리 성능 이슈

이 유저 검색 기능은 SQL의 `LIKE`문을 이용하여 구현하였고, 개발 단계에서 아무런 문제 없이 잘 동작합니다.  
하지만 프로젝트에 사용한 모든 쿼리들에 대해 `실행계획`을 확인하는 과정에서 `성능 이슈`로 이어질 수 있는 부분이 있음을 인지하였습니다. **`LIKE`문을 이용하여 쿼리한 결과, 인덱스를 사용하지 못하고 전체 조회를 하고 있었기 때문**입니다. 이와 같은 쿼리는 유저 수가 많아지면 문제를 야기할 것이 분명하기 때문에 수정이 필요하다고 판단했습니다.

**Full Text Search**

이에 대한 해결 방안으로 `Full Text Search`를 고려하고 있습니다. `Full Text Index`와 `N-gram parser`, `Boolean Mode`를 이용하여 이슈를 해결할 수 있을 것으로 보고 리팩토링을 진행 중입니다. 리팩토링이 끝나면 실제로 계정 수를 복제하여 **이전 코드와 변경 코드에 대한 성능 테스트를 통해 성능이 얼마나 개선될 수 있는지까지 비교 분석할 계획**입니다.
